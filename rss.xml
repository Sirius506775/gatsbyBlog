<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[Gatsby Starter Blog RSS Feed]]></description><link>http://github.com/dylang/node-rss</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 21 Dec 2022 05:40:06 GMT</lastBuildDate><item><title><![CDATA[React - input 태그 사용법]]></title><description><![CDATA[React에서 input태그를 사용하는 방법 input태그는 사용자가 입력을 해도 컴포넌트가 변하지 않습니다. re-rendering이 일어나지 않는다는 말입니다. 1. useRef를 사용하는 방법 (권장하지 않음) id를 사용하지 않고 대신 ref…]]></description><link>null/React - input 태그 사용법/</link><guid isPermaLink="false">null/React - input 태그 사용법/</guid><pubDate>Mon, 19 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h5&gt;React에서 input태그를 사용하는 방법&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;input태그는 사용자가 입력을 해도 컴포넌트가 변하지 않습니다. re-rendering이 일어나지 않는다는 말입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1. useRef를 사용하는 방법 (권장하지 않음)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;id를 사용하지 않고 대신 ref를 사용하는 방법입니다.&lt;/li&gt;
&lt;li&gt;ref를 만드는 이유는 DOM 요소를 사용해야할 경우에 사용하기 위함입니다. ( 빈도 수는 적음)&lt;/li&gt;
&lt;li&gt;input 태그는 빈 곳에 입력을 하거나, 이미 있던 내용을 보여주기 위함의 2가지 목적이 있다는 것을 기억해보면 이 방법은 추천하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2. state를 사용하는 방법&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;value는 re-rendering이 안되기 때문에 일반적으로 input태그를 쓸때는 ref가 아니라 state로 빼라고 말하곤 합니다.&lt;/li&gt;
&lt;li&gt;사용자가 입력을 하면 그 입력값을 가지고 state를 변경해서 다시 렌더링을 하며 이떄 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt; 함수를 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;useState&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;InputEx2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; 
	&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;setText&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
	
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; 
		&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 
			&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;text&apos;&lt;/span&gt; value&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;text&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; onChange&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setText&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;  
			&lt;span class=&quot;token comment&quot;&gt;//onChange() method를 사용해서 setText으로 state를 변경할 수 있다&lt;/span&gt;
			&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; 
		&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
	
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; InputEx2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&gt; 하지만 실제로 외부에서 작업할 때에는 React의 input를 효과적으로 하기위해 만든 수많은 플러그인을 사용한다는 것을 기억하자...!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React - UseState()]]></title><description><![CDATA[useState Hook 리액트의 컴포넌트가 re-rendering 하는 조건 중 하나는 컴포넌트 안에 있는 state가 변경되었을 경우입니다. useState는 리액트가 컴포넌트들을 모니터링하기 위해 만들어진 개념입니다. state…]]></description><link>null/React - UseState()/</link><guid isPermaLink="false">null/React - UseState()/</guid><pubDate>Mon, 19 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h4&gt;useState Hook&lt;/h4&gt;
&lt;p&gt;리액트의 컴포넌트가 re-rendering 하는 조건 중 하나는 컴포넌트 안에 있는 state가 변경되었을 경우입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;useState는 리액트가 컴포넌트들을 모니터링하기 위해 만들어진 개념입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state로 데이터를 만들면 리액트가 모니터링을 할 수 있습니다.&lt;/li&gt;
&lt;li&gt;리액트는 컴포넌트의 상태가 변경되었음을 알아야하기 때문에 리액트에서는 useState를 사용하여 상태를 관리합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;useState는 배열을 반환 하는 호출가능한 함수이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 실행 시 컴포넌트에 있는 값을 쓰는 것이 아니라 useState를 통해 가져온 배열을 사용하는 것&lt;/li&gt;
&lt;li&gt;배열의 첫번째 요소는 초기화된 값이며, 두 번째 값은 초기값을 변경할 수 있는 함수로 구성되어 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;useState 훅은 실제로 react 패키지에 들어있기 때문에 임포트를 해야한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; useState &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;useState()에 전달하는 값은 상태 변수의 디폴트 값이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setTitle&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;setstate를 검사 하는 작동원리&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;setState가 실행이 되면 React는 자기가 원래 가지고 있던 객체랑 setState로 들어온 객체랑 같은 건지 비교를 하는 작업을 거칩니다. ( 때문에 useState를 남발하는 것은 지양)&lt;/li&gt;
&lt;li&gt;만약 이 2개가 같다면 re-render를 하지 않아도 된다고 판단하고 skip합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;** change와 change() **&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;change = 변수의 의미&lt;/li&gt;
&lt;li&gt;change() = 실행한 결과의 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;state를 다루는 진짜 이유는 Re-rendering을 하기 위해서입니다. 다시 컴포넌트를 뿌려주기 위함이 목적입니다.&lt;/p&gt;
&lt;h5&gt;re-render를 하는 3가지 상황&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;컴포넌트의 state가 변경이 되었을 때&lt;/li&gt;
&lt;li&gt;props가 변경이 되었을 때&lt;/li&gt;
&lt;li&gt;상위컴포넌트가 변경이 되어서 re-render가 되면, 하위 컴포넌트도 re-render를 한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[React - 구조 디자인 매뉴얼]]></title><description><![CDATA[react는 Dom이 아닌 JavaScript…]]></description><link>null/React - 구조 디자인 매뉴얼/</link><guid isPermaLink="false">null/React - 구조 디자인 매뉴얼/</guid><pubDate>Mon, 19 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;react는 Dom이 아닌 JavaScript를 중심으로 생각한다.&lt;/h2&gt;
&lt;p&gt;=&gt; 이 패러다임을 받아들여야한다.&lt;/p&gt;
&lt;h5&gt;더 효과적인 컴포넌트를 구성하는 방법&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;아토믹 디자인은 기획 설계 시 적용하고, 실제 구현단계에서는 적용하기 어렵다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;때문에 구현 단계에서는 반대로 위에서 부터 아래로 뿌려주는 형태로 개발한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컴포넌트를 외부로 많이 뺀다고 해서 재사용성이 좋지 않았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후에는 모듈이라는 단위로 빼기 시작한다.&lt;/p&gt;
&lt;h5&gt;설계 원칙&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;확장성과 재사용성 있는 코드&lt;/li&gt;
&lt;li&gt;topic에 따른 코드 분리와 단일 책임을 가지는 컴포넌트를 만들어야함&lt;/li&gt;
&lt;li&gt;외부에 제어를 위임시키는것을 고려하자.&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;리액트에서 배열 선언하는 2가지 방법&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;컴포넌트 안에 배열을 선언하는 방법&lt;/li&gt;
&lt;li&gt;컴포넌트 바깥에 배열을 선언하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;방법을 선택하는 기준
&lt;ul&gt;
&lt;li&gt;컴포넌트 안에 있는 변수나 상수를 써야하는 경우는 배열을 안쪽에 선언하는 것이 좋다.
( = 클로저)&lt;/li&gt;
&lt;li&gt;하지만 독립적이고 고정적인 데이터는 컴포넌트 바깥에 선언하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;리액트의 컴포넌트가 언제 다시 뿌려지는가&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;컴포넌트 안에 있는 state(상태)가 변경되었을 때&lt;/li&gt;
&lt;li&gt;컴포넌트가 여러 개인 구조상에서 상위 컴포넌트가 변경되어서 re-rendering이 되면 하위 컴포넌트들도 리렌더링을 한다.&lt;/li&gt;
&lt;li&gt;props가 변경이 되었을 때(내가 변수에 값을 바꾸는 것이 아니다 xxx )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우리는 효율적인 재사용과 안정적인 컴포넌트를 만들기 위해 Side Effect가 존재하지 않는 컴포넌트로 만들 필요가 있다. =&gt; 순수 컴포넌트 지향&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Udemy React Guide 01 - createRoot(), App.js]]></title><description><![CDATA[index.js 파일이 가장 먼저 실행되는 파일이다. 
React-dom이라는 패키지로부터 reactDOM Object를 가져온다 pakage.json를 살펴보면
로컬에 설치한 dependencies를 확인할 수 있다. ![[Pasted image…]]></description><link>null/Udemy React/</link><guid isPermaLink="false">null/Udemy React/</guid><pubDate>Mon, 19 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;index.js&lt;/strong&gt; 파일이 가장 먼저 실행되는 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;import ReactDOM from &apos;react-dom/client&apos;;&lt;/code&gt;
React-dom이라는 패키지로부터 reactDOM Object를 가져온다&lt;/p&gt;
&lt;p&gt;pakage.json를 살펴보면
로컬에 설치한 dependencies를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;![[Pasted image 20221219150604.png]]&lt;/p&gt;
&lt;p&gt;엄밀히 말하면 별개의 패키지로 나누어 각기 다른 역할을 하지만 두 가지 React 라이브러리에 의존한다.&lt;/p&gt;
&lt;p&gt;index.js처럼 말이다.
해당 라이브러리가 제공하는 기능을 사용할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;이게 현대 JavaScript의 일반적인 작동 방식이다.&lt;/p&gt;
&lt;p&gt;React-dom이라는 패키지로부터 reactDOM Object를 가져와서 creatRoot 메소드를 호출한다.&lt;/p&gt;
&lt;p&gt;![[Pasted image 20221219150631.png]]
이로 인해 주요 엔트리 포인트가 생성된다.&lt;/p&gt;
&lt;p&gt;리액트로 구축될 UI에 대한 주요 hook을 말한다.&lt;/p&gt;
&lt;h3&gt;createRoot 메소드의 역할 :&lt;/h3&gt;
&lt;p&gt;createRoot() 는 리액트로 구축할 UI를 리액프 어플리케이션이 불러온 웹페이지 상에서 어디에 배치해야하는지 리액트에게 알려주는 메소드이다.
이 메소드로 인해 public 폴더에 있는 index.html로 이동하게된다.&lt;/p&gt;
&lt;p&gt;![[Pasted image 20221219150641.png]]&lt;/p&gt;
&lt;p&gt;단일 html파일로 브라우저가 불러오는 파일이다.&lt;/p&gt;
&lt;p&gt;리액트 어플리케이션 전체에서 사용하는 유일한 html 파일이다.
단일 페이지 어플리케이션, SPA라고 불리는 부분이다.&lt;/p&gt;
&lt;p&gt;리액트로 다루는 웹페이지와 UI에서 일어나는 모든 변경사항들을 다룬다.&lt;/p&gt;
&lt;p&gt;엔트리 포인트인 이 단일 HTML 파일은 React가 주도하는 UI가 렌더링되야하는 위치이다.&lt;/p&gt;
&lt;p&gt;![[Pasted image 20221219150648.png]]&lt;/p&gt;
&lt;p&gt;우리는 이 div태그에 react로 구축할 UI를 추가한다.&lt;/p&gt;
&lt;p&gt;React를 기반으로 하는 사용자 인터페이스가 렌더링되어야 하는 건 이 div 태그입니다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactDOM &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react-dom/client&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./index.css&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; App &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./App&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  
&lt;span class=&quot;token comment&quot;&gt;//root 객체를 상수나 변수로 저장&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;root&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//메인 react 어플리케이션이 렌더링되는 부분이다.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//root라는 id를 갖고 있는 dom이 루트라는 것을 react에게 알려준다.&lt;/span&gt;


root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;App &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//root객체에서 render메소드를 호출&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그 다음, root객체에서 render메소드를 호출해서 이 div 태그에 뭘 렌더링해야 하는지 알린다.&lt;/p&gt;
&lt;p&gt;그 다음 ReactDOM에게 렌더링하고 싶은 게 있다고 알린다.&lt;/p&gt;
&lt;p&gt;div 태그에 들어갈 콘텐츠는 App이다.
&lt;code class=&quot;language-text&quot;&gt;import App from &apos;./App&apos;;&lt;/code&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Pure Function]]></title><description><![CDATA[Pure Function(순수함수 <-> Impure Function) 순수함수의 조건 동일한 인자를 넣을 경우 항상 같은 값을 반환해야한다.(외부 상태에 의존 x) 함수가 호출되고 나서 아무런 변화가 없어야한다. (외부 상태 변경 x) 1-…]]></description><link>null/Pure Function(순수 함수)/</link><guid isPermaLink="false">null/Pure Function(순수 함수)/</guid><pubDate>Wed, 07 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Pure Function(순수함수 &amp;#x3C;-&gt; Impure Function)&lt;/p&gt;
&lt;p&gt;순수함수의 조건&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;동일한 인자를 넣을 경우 항상 같은 값을 반환해야한다.(외부 상태에 의존 x)&lt;/li&gt;
&lt;li&gt;함수가 호출되고 나서 아무런 변화가 없어야한다. (외부 상태 변경 x)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1-1. 함수의 인자가 아닌 외부 변수를 사용하지 않아야 합니다. (상수는 OK)&lt;br&gt;
1-2. 함수 내부에서 Math.random()이나 file I/O등 호출때마다 달라지는 값이 없어야 합니다.&lt;br&gt;
2-1. 외부 변수의 값을 수정하지 않아야 합니다.&lt;br&gt;
2-2. 인자로 넘어온 Object나 Array, Date와 같은 값들의 필드를 내부에서 변경하지 않아야 합니다.&lt;br&gt;
2-2. 콘솔, 네트워크, 기타 DOM API등을 사용하지 않아야 합니다.&lt;br&gt;
2-3. try ~ catch등 같은 에러 처리 로직을 사용하지 않아야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;예측 가능&lt;/strong&gt;: 동일한 입력에 대해 예측 가능한 output을 생성한다.&lt;br&gt;
&lt;strong&gt;가독성&lt;/strong&gt;: 독립된 실행 단위를 가지므로 누구나 그 목적을 완전히 이해할 수 있다.&lt;br&gt;
&lt;strong&gt;재사용 가능&lt;/strong&gt;: 함수와 호출자의 동작을 변경하지 않고 코드의 여러 위치에서 함수를 재사용할 수 있다.&lt;br&gt;
테스트 가능**: 독립적인 단위로 테스트 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;=&gt; Pure function은 항상 같은 value를 return 하기 때문에 테스트하기 용이하다.&lt;/p&gt;
&lt;p&gt;Pure Function always return same values.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;My Name is &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Heon&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// returns &apos;My Name is Heon&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;``
&lt;strong&gt;순수함수 + 순수함수 = 순수함수&lt;/strong&gt; 가 되므로 순수함수로 조립된 최종값만 부수효과가 있는 함수를 통해 처리하고, 다시 그 결과를 순수함수를 통해 조립을 하는 방식으로 개발을 하면 우리 목적을 달성할 수 있게 된다.
3&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;함수형 프로그래밍의 개념도&lt;/h2&gt;
&lt;p&gt;Input =&gt; &lt;strong&gt;(순수 함수 =&gt; 순수 함수 =&gt; 순수 함수 =&gt; 순수 함수)&lt;/strong&gt; =&gt; 부수 효과 =&gt; Output1&lt;/p&gt;
&lt;p&gt;Output1 =&gt; Input =&gt; &lt;strong&gt;(순수 함수 =&gt; 순수 함수)&lt;/strong&gt; =&gt; 부수 효과 =&gt; Output2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그래서 이렇게 순수함수를 통해 데이터가 지나가는 경우에는 외부에 영향을 주지 않기 때문에 무한한 조립의 가지수를 다 테스트하지 않고 각 함수만 잘 동작한다면 저 구간은 문제 없을 거라는 것을 확신할 수 있게 됩니다. 이렇게 &lt;strong&gt;값이 변하지 않는 상태를 유지하는 것을 불변성&lt;/strong&gt;(Immutablilty)이라고 합니다.&lt;/p&gt;
&lt;p&gt;#FuntionalProgramming&lt;/p&gt;</content:encoded></item></channel></rss>